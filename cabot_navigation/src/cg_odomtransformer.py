#!/usr/bin/env python

# Copyright (c) 2020 Carnegie Mellon University
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
# generate odom topic from odom transform generated by cartographer
# Daisuke Sato <daisukes@cmu.edu>
# 


import numpy as np
import math
import rospy
import tf
import tf2_ros
import geometry_msgs.msg
import nav_msgs.msg
from copy import deepcopy

# constants
ALPHA = 0.1
TIME_WINDOW = 0.2

# global variables
odoms = []
position = np.array([0, 0, 0])
orientation = np.array([0, 0, 0, 1])


# interporate two quaternion
def getSlerp(o1, o2):
    temp = tf.transformations.quaternion_slerp(o1, o2, ALPHA)
    return np.array(temp)


# convert ros messgae into numpy array
def toArray(v):
    if isinstance(v, geometry_msgs.msg.Quaternion):
        return np.array([v.x, v.y, v.z, v.w])
    if isinstance(v, geometry_msgs.msg.Point):
        return np.array([v.x, v.y, v.z])
    if isinstance(v, geometry_msgs.msg.Vector3):
        return np.array([v.x, v.y, v.z])
    if isinstance(v, list):
        return np.array(v)
    return None


# filter pose
def filterPose(translation, rotation):
    global position, orientation
    position = position * (1-ALPHA) + toArray(translation) * ALPHA
    orientation = getSlerp(orientation, toArray(rotation))


# calculate velocity
def getVelocity(odoms):
    odom1 = odoms[0]
    odom2 = odoms[-1]

    time1 = odom1[2]
    time2 = odom2[2]
    pos1 = toArray(odom1[0])
    pos2 = toArray(odom2[0])
    rot1 = toArray(odom1[1])
    rot2 = toArray(odom2[1])
        
    # difference of time
    dt = time2.to_sec() - time1.to_sec()
    if dt == 0:
        return None
    
    # calculate difference between two points
    dp = pos2 - pos1

    # get moving direction
    rpy = tf.transformations.euler_from_quaternion(rot1)
    bx = math.cos(rpy[2])
    by = math.sin(rpy[2])
    sign = 1 if (dp[0]*bx + dp[1]*by) / np.linalg.norm(dp) > 0 else -1

    # calculate difference of angle q2 = qr * q1
    q1_inv = rot1 * np.array([1, 1, 1, -1])
    q2 = rot2
    qr = tf.transformations.quaternion_multiply(q2, q1_inv)
    # convert quaternion to rpy
    rpy = tf.transformations.euler_from_quaternion(qr)

    
    # create Twist message
    twist = geometry_msgs.msg.Twist()
    twist.linear.x = sign * round(np.linalg.norm(dp) / dt, 2)
    twist.angular.z = round(rpy[2] / dt, 2)
    # assumes zero for others
    return twist


def publishTransform(data, odomInput, tfOutput):
    tfBroadcaster = tf2_ros.TransformBroadcaster()
    
    t = geometry_msgs.msg.TransformStamped()
    t.header.stamp = rospy.Time.now()
    t.header.frame_id = odomInput
    t.child_frame_id = tfOutput
    t.transform.translation = data.pose.pose.position
    t.transform.rotation = data.pose.pose.orientation
    
    tfBroadcaster.sendTransform(t)


def callback(translation, rotation, odomPublisher, tfParent, tfChild):
    global odoms, position, orientation
    
    odoms.append([translation, rotation, rospy.get_rostime()])
    if len(odoms) > 40 * TIME_WINDOW:
        odoms.pop(0)
        
    # filter it
    filterPose(translation, rotation)
    
    # use filtered position for odometry
    odom = nav_msgs.msg.Odometry()
    odom.header.stamp = rospy.get_rostime()
    odom.header.frame_id = tfParent
    odom.child_frame_id = tfChild
    odom.pose.pose.position = geometry_msgs.msg.Point(*position)
    odom.pose.pose.orientation = geometry_msgs.msg.Quaternion(*rotation)
    if len(odoms) > 1:
        vel = getVelocity(odoms)
        if vel is not None:
            odom.twist.twist = vel
            odomPublisher.publish(odom)



if __name__ == "__main__":
    rospy.init_node("cg_odomtransformer")
    
    listener = tf.TransformListener()
    
    odomTopic = rospy.get_param("~odom_topic", "odom")
    tfParent = rospy.get_param("~tf_parent", "odom")
    tfChild = rospy.get_param("~tf_child", "base_footprint")
    
    odomPublisher = rospy.Publisher(odomTopic, nav_msgs.msg.Odometry,
                                    queue_size=10)

    rate = rospy.Rate(40.0)
    while not rospy.is_shutdown():
        try:
            (translation, rotation) = \
                listener.lookupTransform(tfParent, tfChild, rospy.Time(0))
        except (tf.LookupException, tf.ConnectivityException):
            continue
        
        callback(translation, rotation, odomPublisher, tfParent, tfChild)
        rate.sleep()
        


rospy.spin()
